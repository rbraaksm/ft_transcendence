import { __decorate, __metadata } from "tslib";
import { Injectable } from '@angular/core';
import { PlatformLocation, Location } from '@angular/common';
import { BehaviorSubject } from 'rxjs';
import { distinctUntilChanged, map } from 'rxjs/operators';
import * as queryString from 'query-string';
import { UrlParser } from './url-parser';
import { compareParams } from './route-params.service';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "./url-parser";
let Router = class Router {
    constructor(location, platformLocation, urlParser) {
        this.location = location;
        this.platformLocation = platformLocation;
        this.urlParser = urlParser;
        this.state$ = new BehaviorSubject({
            url: this.location.path(),
            queryParams: {},
            hash: '',
        });
        this.url$ = this.state$.pipe(map((state) => state.url), distinctUntilChanged());
        this.hash$ = this.state$.pipe(map((state) => state.hash), distinctUntilChanged());
        this.queryParams$ = this.state$.pipe(map((state) => state.queryParams), distinctUntilChanged(compareParams));
        this.location.subscribe(() => {
            this.nextState(this.getLocation());
        });
        this.nextState(this.getLocation());
    }
    go(url, queryParams, hash) {
        this.location.go(this.serializeUrl(url, queryParams, hash));
        this.nextState(this.getLocation());
    }
    replace(url, queryParams, hash) {
        this.location.replaceState(this.serializeUrl(url, queryParams, hash));
        this.nextState(this.getLocation());
    }
    serializeUrl(url, queryParams, hash) {
        // if relative path
        if (!url.startsWith('/')) {
            url = this.urlParser.joinUrls(this.location.path(), url);
        }
        return (url +
            (queryParams ? `?${queryString.stringify(queryParams)}` : '') +
            `${hash ? '#' + hash : ''}`);
    }
    getExternalUrl(url) {
        return this.location.prepareExternalUrl(url);
    }
    parseSearchParams(searchParams) {
        const queryParams = {};
        searchParams.forEach((value, key) => {
            queryParams[key] = value;
        });
        return queryParams;
    }
    normalizePath(path) {
        return this.location.normalize(path);
    }
    getLocation() {
        return this.platformLocation.href;
    }
    nextState(url) {
        const parsedUrl = this._parseUrl(url);
        this.state$.next({
            url: parsedUrl.pathname,
            queryParams: this.parseSearchParams(parsedUrl.searchParams),
            hash: parsedUrl.hash ? parsedUrl.hash.split('#')[0] : '',
        });
    }
    _parseUrl(path) {
        return this.urlParser.parse(path);
    }
};
Router.ctorParameters = () => [
    { type: Location },
    { type: PlatformLocation },
    { type: UrlParser }
];
Router.ɵprov = i0.ɵɵdefineInjectable({ factory: function Router_Factory() { return new Router(i0.ɵɵinject(i1.Location), i0.ɵɵinject(i1.PlatformLocation), i0.ɵɵinject(i2.UrlParser)); }, token: Router, providedIn: "root" });
Router = __decorate([
    Injectable({
        providedIn: 'root',
    }),
    __metadata("design:paramtypes", [Location,
        PlatformLocation,
        UrlParser])
], Router);
export { Router };
//# sourceMappingURL=router.service.js.map