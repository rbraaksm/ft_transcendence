var RouteComponent_1;
import { __decorate, __metadata } from "tslib";
import { Component, OnInit, Input, Type, ViewContainerRef, ComponentFactoryResolver, ContentChild, TemplateRef, ChangeDetectionStrategy, Self, NgModuleFactory, Compiler, OnDestroy, } from '@angular/core';
import { Subject, BehaviorSubject, of, from } from 'rxjs';
import { distinctUntilChanged, filter, takeUntil, mergeMap, withLatestFrom, map, } from 'rxjs/operators';
import { RouteParams, RoutePath } from './route-params.service';
import { RouterComponent } from './router.component';
import { Router } from './router.service';
export function getRouteParams(routeComponent) {
    return routeComponent.routeParams$;
}
export function getRoutePath(routeComponent) {
    return routeComponent.routePath$;
}
let RouteComponent = RouteComponent_1 = class RouteComponent {
    constructor(router, routerComponent, resolver, viewContainerRef, compiler) {
        this.router = router;
        this.routerComponent = routerComponent;
        this.resolver = resolver;
        this.viewContainerRef = viewContainerRef;
        this.compiler = compiler;
        this.reuse = true;
        this.destroy$ = new Subject();
        this.state$ = new BehaviorSubject({
            params: {},
            path: '',
            shouldRender: false,
        });
        this.shouldRender$ = this.state$.pipe(map((state) => state.shouldRender));
        this.routeParams$ = this.state$.pipe(map((state) => state.params), distinctUntilChanged(), takeUntil(this.destroy$));
        this.routePath$ = this.state$.pipe(map((state) => state.path), distinctUntilChanged(), takeUntil(this.destroy$));
    }
    get path() {
        return this._path;
    }
    set path(value) {
        this._path = this.sanitizePath(value);
    }
    ngOnInit() {
        // account for root level routes, don't add the basePath
        const path = this.routerComponent.parentRouterComponent
            ? this.routerComponent.parentRouterComponent.basePath + this.path
            : this.path;
        this.route = this.registerRoute(path, this.exact, this.load);
        this.routerComponent.activeRoute$
            .pipe(filter((ar) => ar !== null), distinctUntilChanged(), withLatestFrom(this.shouldRender$), mergeMap(([current, rendered]) => {
            if (current.route === this.route) {
                if (this.redirectTo) {
                    this.router.go(this.redirectTo);
                    return of(null);
                }
                this.updateState({
                    params: current.params,
                    path: current.path,
                });
                if (!rendered) {
                    if (!this.reuse) {
                        this.clearView();
                    }
                    return this.loadAndRender(current.route);
                }
                return of(null);
            }
            else if (rendered) {
                return of(this.clearView());
            }
            return of(null);
        }), takeUntil(this.destroy$))
            .subscribe();
    }
    ngOnDestroy() {
        this.routerComponent.unregisterRoute(this.route);
        this.destroy$.next();
    }
    registerRoute(path, exact, load) {
        return this.routerComponent.registerRoute({
            path: path,
            load: load,
            options: this.routeOptions || { exact: exact },
        });
    }
    loadAndRender(route) {
        if (route.load) {
            return from(route.load().then((componentOrModule) => {
                if (componentOrModule instanceof NgModuleFactory) {
                    const moduleRef = componentOrModule.create(this.viewContainerRef.injector);
                    const component = moduleRef.instance.routeComponent;
                    this.renderComponent(component);
                }
                else if (componentOrModule.Éµmod) {
                    return this.compiler
                        .compileModuleAsync(componentOrModule)
                        .then((moduleFactory) => {
                        const moduleRef = moduleFactory.create(this.viewContainerRef.injector);
                        const component = moduleRef.instance.routeComponent;
                        this.renderComponent(component);
                        return true;
                    });
                }
                else {
                    this.renderComponent(componentOrModule);
                }
                return true;
            }));
        }
        else {
            this.showTemplate();
            return of(true);
        }
    }
    renderComponent(component) {
        const componentFactory = this.resolver.resolveComponentFactory(component);
        this.showTemplate();
        this.viewContainerRef.createComponent(componentFactory, this.viewContainerRef.length, this.viewContainerRef.injector);
    }
    clearComponent() {
        this.viewContainerRef.clear();
        this.hideTemplate();
    }
    showTemplate() {
        setTimeout(() => {
            this.updateState({ shouldRender: true });
        });
    }
    hideTemplate() {
        this.updateState({ shouldRender: false });
    }
    clearView() {
        if (this.load) {
            this.clearComponent();
        }
        else {
            this.hideTemplate();
        }
    }
    sanitizePath(path) {
        const trimmed = path.trim();
        return trimmed.startsWith('/') ? trimmed : `/${trimmed}`;
    }
    updateState(newState) {
        this.state$.next(Object.assign(Object.assign({}, this.state$.value), newState));
    }
};
RouteComponent.ctorParameters = () => [
    { type: Router },
    { type: RouterComponent },
    { type: ComponentFactoryResolver },
    { type: ViewContainerRef },
    { type: Compiler }
];
__decorate([
    ContentChild(TemplateRef),
    __metadata("design:type", TemplateRef)
], RouteComponent.prototype, "template", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RouteComponent.prototype, "path", null);
__decorate([
    Input(),
    __metadata("design:type", Type)
], RouteComponent.prototype, "component", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], RouteComponent.prototype, "load", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RouteComponent.prototype, "reuse", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], RouteComponent.prototype, "redirectTo", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], RouteComponent.prototype, "exact", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RouteComponent.prototype, "routeOptions", void 0);
RouteComponent = RouteComponent_1 = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: 'route',
        template: `
    <ng-container
      *ngIf="(shouldRender$ | async) && template"
      [ngTemplateOutlet]="template"
    >
    </ng-container>
  `,
        changeDetection: ChangeDetectionStrategy.OnPush,
        providers: [
            {
                provide: RouteParams,
                useFactory: getRouteParams,
                deps: [[new Self(), RouteComponent_1]],
            },
            {
                provide: RoutePath,
                useFactory: getRoutePath,
                deps: [[new Self(), RouteComponent_1]],
            },
        ]
    }),
    __metadata("design:paramtypes", [Router,
        RouterComponent,
        ComponentFactoryResolver,
        ViewContainerRef,
        Compiler])
], RouteComponent);
export { RouteComponent };
//# sourceMappingURL=route.component.js.map