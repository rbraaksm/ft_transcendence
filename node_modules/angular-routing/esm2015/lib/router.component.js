import { __decorate, __metadata, __param } from "tslib";
import { Component, SkipSelf, Optional, } from '@angular/core';
import { combineLatest, Subject, BehaviorSubject } from 'rxjs';
import { tap, takeUntil, distinctUntilChanged, debounceTime, map, } from 'rxjs/operators';
import { Router } from './router.service';
import { compareParams } from './route-params.service';
import { compareRoutes } from './utils/compare-routes';
import { matchRoute, parsePath } from './utils/path-parser';
let RouterComponent = class RouterComponent {
    // support multiple "routers"
    // router (base /)
    // blog(.*?)
    // router (base /blog)
    // post1(blog/post1/(.*?)
    // post2
    // post3
    constructor(router, parentRouterComponent) {
        this.router = router;
        this.parentRouterComponent = parentRouterComponent;
        this.destroy$ = new Subject();
        this.state$ = new BehaviorSubject({
            activeRoute: null,
            routes: [],
        });
        this.activeRoute$ = this.state$.pipe(map((state) => state.activeRoute), distinctUntilChanged(this.compareActiveRoutes), takeUntil(this.destroy$));
        this.routes$ = this.state$.pipe(map((state) => state.routes), distinctUntilChanged(this.compareRoutes), takeUntil(this.destroy$));
        this.basePath = '';
    }
    ngOnInit() {
        combineLatest([this.routes$.pipe(debounceTime(1)), this.router.url$])
            .pipe(distinctUntilChanged(), tap(([routes, url]) => {
            let routeToRender = null;
            for (const route of routes) {
                routeToRender = this.isRouteMatch(url, route);
                if (routeToRender) {
                    this.setRoute(url, route);
                    break;
                }
            }
            if (!routeToRender) {
                this.setActiveRoute({ route: null, params: {}, path: '' });
            }
        }), takeUntil(this.destroy$))
            .subscribe();
    }
    setRoute(url, route) {
        this.basePath = route.path;
        const match = matchRoute(url, route);
        this.setActiveRoute({
            route,
            params: (match === null || match === void 0 ? void 0 : match.params) || {},
            path: (match === null || match === void 0 ? void 0 : match.path) || '',
        });
    }
    registerRoute(route) {
        route.matcher = route.matcher || parsePath(route);
        this.updateRoutes(route);
        return route;
    }
    setActiveRoute(activeRoute) {
        this.updateState({ activeRoute });
    }
    unregisterRoute(route) {
        this.updateRoutes(Object.assign(Object.assign({}, route), { unregister: true }));
    }
    normalizePath(path) {
        return this.router.normalizePath(path);
    }
    ngOnDestroy() {
        this.destroy$.next();
    }
    isRouteMatch(url, route) {
        var _a;
        return (_a = route.matcher) === null || _a === void 0 ? void 0 : _a.exec(url);
    }
    compareActiveRoutes(previous, current) {
        if (previous === current) {
            return true;
        }
        if (!previous) {
            return false;
        }
        return (previous.path === current.path &&
            compareParams(previous.params, current.params) &&
            previous.route.path === current.route.path &&
            previous.route.options.exact === current.route.options.exact);
    }
    compareRoutes(previous, current) {
        if (previous === current) {
            return true;
        }
        if (!previous) {
            return false;
        }
        return (previous.length === current.length &&
            previous.every((route, i) => route[i] === current[i]));
    }
    updateState(newState) {
        this.state$.next(Object.assign(Object.assign({}, this.state$.value), newState));
    }
    updateRoutes(route) {
        const routes = this.state$.value.routes;
        if (route.unregister) {
            this.updateState({
                routes: routes.filter((r) => r.matcher !== route.matcher),
            });
        }
        else {
            this.updateState({ routes: routes.concat(route).sort(compareRoutes) });
        }
    }
};
RouterComponent.ctorParameters = () => [
    { type: Router },
    { type: RouterComponent, decorators: [{ type: SkipSelf }, { type: Optional }] }
];
RouterComponent = __decorate([
    Component({
        // tslint:disable-next-line:component-selector
        selector: 'router',
        template: '<ng-content></ng-content>'
    }),
    __param(1, SkipSelf()), __param(1, Optional()),
    __metadata("design:paramtypes", [Router,
        RouterComponent])
], RouterComponent);
export { RouterComponent };
//# sourceMappingURL=router.component.js.map