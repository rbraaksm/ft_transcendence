const PARAM_PREFIX = ':';
const DIV = '\\/'; // /
const DIV_PARAM = `(?:${DIV}([^\\/#\\?]+?))`; // capturing group for one or more of not (/, # or ?), optional (TODO: check if optional is needed)
const PATH_END = '[\\/#\\?]'; // path end: /, # or ?
const END = '[]|$'; // null or end
const EXACT_END = `${PATH_END}?$`; // match PATH_END optionally and END
const WILDCARD = `(?:${PATH_END}(?=${END}))?`; // match optionally PATH_END followed by END
const NON_EXACT_END = `${WILDCARD}(?=${PATH_END}|${END})`; // match WILDCARD followed by PATH_END or END
export function getPathSegments(route) {
    const sanitizedPath = route.path.replace(/^\//, '').replace(/(?:\/$)/, '');
    return sanitizedPath ? sanitizedPath.split('/') : [];
}
export const parsePath = (route) => {
    var _a;
    const segments = getPathSegments(route);
    const regexBody = segments.reduce((acc, segment) => segment.startsWith(PARAM_PREFIX)
        ? `${acc}${DIV_PARAM}`
        : `${acc}${DIV}${segment}`, '');
    if ((_a = route.options.exact) !== null && _a !== void 0 ? _a : true) {
        return new RegExp(`^${regexBody}${EXACT_END}`, 'i');
    }
    else {
        return new RegExp(`^${regexBody}${regexBody ? NON_EXACT_END : WILDCARD}`, 'i');
    }
};
export const matchRoute = (url, route) => {
    var _a;
    const match = (_a = route.matcher) === null || _a === void 0 ? void 0 : _a.exec(url);
    if (!match) {
        return;
    }
    const keys = getPathSegments(route)
        .filter((s) => s.startsWith(PARAM_PREFIX))
        .map((s) => s.slice(1));
    return {
        path: match[0],
        params: keys.reduce((acc, key, index) => (Object.assign(Object.assign({}, acc), { [key]: match[index + 1] })), {}),
    };
};
//# sourceMappingURL=path-parser.js.map