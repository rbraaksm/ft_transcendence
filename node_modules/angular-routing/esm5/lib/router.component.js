import { __assign, __decorate, __metadata, __param, __read, __values } from "tslib";
import { Component, SkipSelf, Optional, } from '@angular/core';
import { combineLatest, Subject, BehaviorSubject } from 'rxjs';
import { tap, takeUntil, distinctUntilChanged, debounceTime, map, } from 'rxjs/operators';
import { Router } from './router.service';
import { compareParams } from './route-params.service';
import { compareRoutes } from './utils/compare-routes';
import { matchRoute, parsePath } from './utils/path-parser';
var RouterComponent = /** @class */ (function () {
    // support multiple "routers"
    // router (base /)
    // blog(.*?)
    // router (base /blog)
    // post1(blog/post1/(.*?)
    // post2
    // post3
    function RouterComponent(router, parentRouterComponent) {
        this.router = router;
        this.parentRouterComponent = parentRouterComponent;
        this.destroy$ = new Subject();
        this.state$ = new BehaviorSubject({
            activeRoute: null,
            routes: [],
        });
        this.activeRoute$ = this.state$.pipe(map(function (state) { return state.activeRoute; }), distinctUntilChanged(this.compareActiveRoutes), takeUntil(this.destroy$));
        this.routes$ = this.state$.pipe(map(function (state) { return state.routes; }), distinctUntilChanged(this.compareRoutes), takeUntil(this.destroy$));
        this.basePath = '';
    }
    RouterComponent.prototype.ngOnInit = function () {
        var _this = this;
        combineLatest([this.routes$.pipe(debounceTime(1)), this.router.url$])
            .pipe(distinctUntilChanged(), tap(function (_a) {
            var e_1, _b;
            var _c = __read(_a, 2), routes = _c[0], url = _c[1];
            var routeToRender = null;
            try {
                for (var routes_1 = __values(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {
                    var route = routes_1_1.value;
                    routeToRender = _this.isRouteMatch(url, route);
                    if (routeToRender) {
                        _this.setRoute(url, route);
                        break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (routes_1_1 && !routes_1_1.done && (_b = routes_1.return)) _b.call(routes_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (!routeToRender) {
                _this.setActiveRoute({ route: null, params: {}, path: '' });
            }
        }), takeUntil(this.destroy$))
            .subscribe();
    };
    RouterComponent.prototype.setRoute = function (url, route) {
        this.basePath = route.path;
        var match = matchRoute(url, route);
        this.setActiveRoute({
            route: route,
            params: (match === null || match === void 0 ? void 0 : match.params) || {},
            path: (match === null || match === void 0 ? void 0 : match.path) || '',
        });
    };
    RouterComponent.prototype.registerRoute = function (route) {
        route.matcher = route.matcher || parsePath(route);
        this.updateRoutes(route);
        return route;
    };
    RouterComponent.prototype.setActiveRoute = function (activeRoute) {
        this.updateState({ activeRoute: activeRoute });
    };
    RouterComponent.prototype.unregisterRoute = function (route) {
        this.updateRoutes(__assign(__assign({}, route), { unregister: true }));
    };
    RouterComponent.prototype.normalizePath = function (path) {
        return this.router.normalizePath(path);
    };
    RouterComponent.prototype.ngOnDestroy = function () {
        this.destroy$.next();
    };
    RouterComponent.prototype.isRouteMatch = function (url, route) {
        var _a;
        return (_a = route.matcher) === null || _a === void 0 ? void 0 : _a.exec(url);
    };
    RouterComponent.prototype.compareActiveRoutes = function (previous, current) {
        if (previous === current) {
            return true;
        }
        if (!previous) {
            return false;
        }
        return (previous.path === current.path &&
            compareParams(previous.params, current.params) &&
            previous.route.path === current.route.path &&
            previous.route.options.exact === current.route.options.exact);
    };
    RouterComponent.prototype.compareRoutes = function (previous, current) {
        if (previous === current) {
            return true;
        }
        if (!previous) {
            return false;
        }
        return (previous.length === current.length &&
            previous.every(function (route, i) { return route[i] === current[i]; }));
    };
    RouterComponent.prototype.updateState = function (newState) {
        this.state$.next(__assign(__assign({}, this.state$.value), newState));
    };
    RouterComponent.prototype.updateRoutes = function (route) {
        var routes = this.state$.value.routes;
        if (route.unregister) {
            this.updateState({
                routes: routes.filter(function (r) { return r.matcher !== route.matcher; }),
            });
        }
        else {
            this.updateState({ routes: routes.concat(route).sort(compareRoutes) });
        }
    };
    RouterComponent.ctorParameters = function () { return [
        { type: Router },
        { type: RouterComponent, decorators: [{ type: SkipSelf }, { type: Optional }] }
    ]; };
    RouterComponent = __decorate([
        Component({
            // tslint:disable-next-line:component-selector
            selector: 'router',
            template: '<ng-content></ng-content>'
        }),
        __param(1, SkipSelf()), __param(1, Optional()),
        __metadata("design:paramtypes", [Router,
            RouterComponent])
    ], RouterComponent);
    return RouterComponent;
}());
export { RouterComponent };
//# sourceMappingURL=router.component.js.map