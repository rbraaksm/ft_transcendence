{"version":3,"file":"compare-routes.js","sourceRoot":"ng://angular-routing/","sources":["lib/utils/compare-routes.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,eAAe,EAAE,MAAM,eAAe,CAAC;AAEhD;;;;;;;;GAQG;AACH,MAAM,CAAC,IAAM,aAAa,GAAG,UAAC,CAAQ,EAAE,CAAQ;;IAC9C,sFAAsF;IACtF,IAAI,CAAC,CAAC,OAAO,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE;QACjD,OAAO,CAAC,CAAC;KACV;IACD,IAAM,SAAS,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;IACrC,IAAM,SAAS,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;IAErC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,MAAM,EAAE,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE,EAAE;QACrE,IAAM,OAAO,GAAG,eAAe,CAAC,SAAS,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC;QACzD,IAAI,OAAO,EAAE;YACX,OAAO,OAAO,CAAC;SAChB;KACF;IACD,0CAA0C;IAC1C,OAAO,OAAA,CAAC,CAAC,OAAO,CAAC,KAAK,mCAAI,IAAI,EAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC;AAEF,SAAS,eAAe,CACtB,SAAmB,EACnB,SAAmB,EACnB,KAAa;IAEb,wCAAwC;IACxC,IAAI,SAAS,CAAC,MAAM,IAAI,KAAK,EAAE;QAC7B,OAAO,CAAC,CAAC;KACV;IACD,yCAAyC;IACzC,IAAI,SAAS,CAAC,MAAM,IAAI,KAAK,EAAE;QAC7B,OAAO,CAAC,CAAC,CAAC;KACX;IACD,IAAI,SAAS,CAAC,KAAK,CAAC,KAAK,SAAS,CAAC,KAAK,CAAC,EAAE;QACzC,OAAO,CAAC,CAAC;KACV;IACD,uCAAuC;IACvC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;QACrB,OAAO,CAAC,CAAC;KACV;IACD,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;QACrB,OAAO,CAAC,CAAC,CAAC;KACX;IACD,qBAAqB;IACrB,IAAI,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,IAAI,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE;QAC1D,OAAO,CAAC,CAAC;KACV;IACD,yCAAyC;IACzC,IAAI,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE;QAC7B,OAAO,CAAC,CAAC;KACV;IACD,IAAI,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE;QAC7B,OAAO,CAAC,CAAC,CAAC;KACX;IACD,yCAAyC;IACzC,OAAO,SAAS,CAAC,KAAK,CAAC,CAAC,aAAa,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;AAC1D,CAAC;AAED,SAAS,OAAO,CAAC,OAAe;IAC9B,OAAO,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AACjC,CAAC","sourcesContent":["import { Route } from '../route';\nimport { getPathSegments } from './path-parser';\n\n/**\n * Compares two routes and returns sorting number\n * 0 - equal\n * -1 - `a` has priority over `b`\n * 1 - `b` has priority over `a`\n *\n * @param a Route\n * @param b Route\n */\nexport const compareRoutes = (a: Route, b: Route): number => {\n  // as matchers combine normalized path and `exact` option it's safe to compare regexps\n  if (a.matcher.toString() === b.matcher.toString()) {\n    return 0;\n  }\n  const aSegments = getPathSegments(a);\n  const bSegments = getPathSegments(b);\n\n  for (let i = 0; i < Math.max(aSegments.length, bSegments.length); i++) {\n    const current = compareSegments(aSegments, bSegments, i);\n    if (current) {\n      return current;\n    }\n  }\n  // when paths are same, exact has priority\n  return a.options.exact ?? true ? -1 : 1;\n};\n\nfunction compareSegments(\n  aSegments: string[],\n  bSegments: string[],\n  index: number\n): number {\n  // if a has no more segments -> return 1\n  if (aSegments.length <= index) {\n    return 1;\n  }\n  // if b has no more segments -> return -1\n  if (bSegments.length <= index) {\n    return -1;\n  }\n  if (aSegments[index] === bSegments[index]) {\n    return 0;\n  }\n  // prioritize non-empty path over empty\n  if (!aSegments[index]) {\n    return 1;\n  }\n  if (!bSegments[index]) {\n    return -1;\n  }\n  // ignore param names\n  if (isParam(aSegments[index]) && isParam(bSegments[index])) {\n    return 0;\n  }\n  // static segment has priority over param\n  if (isParam(aSegments[index])) {\n    return 1;\n  }\n  if (isParam(bSegments[index])) {\n    return -1;\n  }\n  // when all is same run string comparison\n  return aSegments[index].localeCompare(bSegments[index]);\n}\n\nfunction isParam(segment: string): boolean {\n  return segment.startsWith(':');\n}\n"]}