import { __assign } from "tslib";
var PARAM_PREFIX = ':';
var DIV = '\\/'; // /
var DIV_PARAM = "(?:" + DIV + "([^\\/#\\?]+?))"; // capturing group for one or more of not (/, # or ?), optional (TODO: check if optional is needed)
var PATH_END = '[\\/#\\?]'; // path end: /, # or ?
var END = '[]|$'; // null or end
var EXACT_END = PATH_END + "?$"; // match PATH_END optionally and END
var WILDCARD = "(?:" + PATH_END + "(?=" + END + "))?"; // match optionally PATH_END followed by END
var NON_EXACT_END = WILDCARD + "(?=" + PATH_END + "|" + END + ")"; // match WILDCARD followed by PATH_END or END
export function getPathSegments(route) {
    var sanitizedPath = route.path.replace(/^\//, '').replace(/(?:\/$)/, '');
    return sanitizedPath ? sanitizedPath.split('/') : [];
}
export var parsePath = function (route) {
    var _a;
    var segments = getPathSegments(route);
    var regexBody = segments.reduce(function (acc, segment) {
        return segment.startsWith(PARAM_PREFIX)
            ? "" + acc + DIV_PARAM
            : "" + acc + DIV + segment;
    }, '');
    if ((_a = route.options.exact) !== null && _a !== void 0 ? _a : true) {
        return new RegExp("^" + regexBody + EXACT_END, 'i');
    }
    else {
        return new RegExp("^" + regexBody + (regexBody ? NON_EXACT_END : WILDCARD), 'i');
    }
};
export var matchRoute = function (url, route) {
    var _a;
    var match = (_a = route.matcher) === null || _a === void 0 ? void 0 : _a.exec(url);
    if (!match) {
        return;
    }
    var keys = getPathSegments(route)
        .filter(function (s) { return s.startsWith(PARAM_PREFIX); })
        .map(function (s) { return s.slice(1); });
    return {
        path: match[0],
        params: keys.reduce(function (acc, key, index) {
            var _a;
            return (__assign(__assign({}, acc), (_a = {}, _a[key] = match[index + 1], _a)));
        }, {}),
    };
};
//# sourceMappingURL=path-parser.js.map