{"version":3,"file":"path-parser.js","sourceRoot":"ng://angular-routing/","sources":["lib/utils/path-parser.ts"],"names":[],"mappings":";AAGA,IAAM,YAAY,GAAG,GAAG,CAAC;AAOzB,IAAM,GAAG,GAAG,KAAK,CAAC,CAAC,IAAI;AACvB,IAAM,SAAS,GAAG,QAAM,GAAG,oBAAiB,CAAC,CAAC,mGAAmG;AACjJ,IAAM,QAAQ,GAAG,WAAW,CAAC,CAAC,sBAAsB;AACpD,IAAM,GAAG,GAAG,MAAM,CAAC,CAAC,cAAc;AAClC,IAAM,SAAS,GAAM,QAAQ,OAAI,CAAC,CAAC,oCAAoC;AACvE,IAAM,QAAQ,GAAG,QAAM,QAAQ,WAAM,GAAG,QAAK,CAAC,CAAC,4CAA4C;AAC3F,IAAM,aAAa,GAAM,QAAQ,WAAM,QAAQ,SAAI,GAAG,MAAG,CAAC,CAAC,6CAA6C;AAExG,MAAM,UAAU,eAAe,CAAC,KAAY;IAC1C,IAAM,aAAa,GAAG,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;IAC3E,OAAO,aAAa,CAAC,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;AACvD,CAAC;AAED,MAAM,CAAC,IAAM,SAAS,GAAG,UAAC,KAAY;;IACpC,IAAM,QAAQ,GAAG,eAAe,CAAC,KAAK,CAAC,CAAC;IACxC,IAAM,SAAS,GAAG,QAAQ,CAAC,MAAM,CAC/B,UAAC,GAAG,EAAE,OAAO;QACX,OAAA,OAAO,CAAC,UAAU,CAAC,YAAY,CAAC;YAC9B,CAAC,CAAC,KAAG,GAAG,GAAG,SAAW;YACtB,CAAC,CAAC,KAAG,GAAG,GAAG,GAAG,GAAG,OAAS;IAF5B,CAE4B,EAC9B,EAAE,CACH,CAAC;IAEF,UAAI,KAAK,CAAC,OAAO,CAAC,KAAK,mCAAI,IAAI,EAAE;QAC/B,OAAO,IAAI,MAAM,CAAC,MAAI,SAAS,GAAG,SAAW,EAAE,GAAG,CAAC,CAAC;KACrD;SAAM;QACL,OAAO,IAAI,MAAM,CACf,MAAI,SAAS,IAAG,SAAS,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,QAAQ,CAAE,EACtD,GAAG,CACJ,CAAC;KACH;AACH,CAAC,CAAC;AAEF,MAAM,CAAC,IAAM,UAAU,GAAG,UACxB,GAAW,EACX,KAAY;;IAEZ,IAAM,KAAK,SAAG,KAAK,CAAC,OAAO,0CAAE,IAAI,CAAC,GAAG,CAAC,CAAC;IACvC,IAAI,CAAC,KAAK,EAAE;QACV,OAAO;KACR;IACD,IAAM,IAAI,GAAG,eAAe,CAAC,KAAK,CAAC;SAChC,MAAM,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,UAAU,CAAC,YAAY,CAAC,EAA1B,CAA0B,CAAC;SACzC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAV,CAAU,CAAC,CAAC;IAE1B,OAAO;QACL,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;QACd,MAAM,EAAE,IAAI,CAAC,MAAM,CACjB,UAAC,GAAG,EAAE,GAAG,EAAE,KAAK;;YAAK,OAAA,uBAAM,GAAG,gBAAG,GAAG,IAAG,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,OAAG;QAArC,CAAqC,EAC1D,EAAE,CACH;KACF,CAAC;AACJ,CAAC,CAAC","sourcesContent":["import { Route } from '../route';\nimport { Params } from '../route-params.service';\n\nconst PARAM_PREFIX = ':';\n\nexport interface RouteMatch {\n  path: string;\n  params: Params;\n}\n\nconst DIV = '\\\\/'; // /\nconst DIV_PARAM = `(?:${DIV}([^\\\\/#\\\\?]+?))`; // capturing group for one or more of not (/, # or ?), optional (TODO: check if optional is needed)\nconst PATH_END = '[\\\\/#\\\\?]'; // path end: /, # or ?\nconst END = '[]|$'; // null or end\nconst EXACT_END = `${PATH_END}?$`; // match PATH_END optionally and END\nconst WILDCARD = `(?:${PATH_END}(?=${END}))?`; // match optionally PATH_END followed by END\nconst NON_EXACT_END = `${WILDCARD}(?=${PATH_END}|${END})`; // match WILDCARD followed by PATH_END or END\n\nexport function getPathSegments(route: Route): string[] {\n  const sanitizedPath = route.path.replace(/^\\//, '').replace(/(?:\\/$)/, '');\n  return sanitizedPath ? sanitizedPath.split('/') : [];\n}\n\nexport const parsePath = (route: Route): RegExp => {\n  const segments = getPathSegments(route);\n  const regexBody = segments.reduce(\n    (acc, segment) =>\n      segment.startsWith(PARAM_PREFIX)\n        ? `${acc}${DIV_PARAM}`\n        : `${acc}${DIV}${segment}`,\n    ''\n  );\n\n  if (route.options.exact ?? true) {\n    return new RegExp(`^${regexBody}${EXACT_END}`, 'i');\n  } else {\n    return new RegExp(\n      `^${regexBody}${regexBody ? NON_EXACT_END : WILDCARD}`,\n      'i'\n    );\n  }\n};\n\nexport const matchRoute = (\n  url: string,\n  route: Route\n): RouteMatch | undefined => {\n  const match = route.matcher?.exec(url);\n  if (!match) {\n    return;\n  }\n  const keys = getPathSegments(route)\n    .filter((s) => s.startsWith(PARAM_PREFIX))\n    .map((s) => s.slice(1));\n\n  return {\n    path: match[0],\n    params: keys.reduce(\n      (acc, key, index) => ({ ...acc, [key]: match[index + 1] }),\n      {}\n    ),\n  };\n};\n"]}