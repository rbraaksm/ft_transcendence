(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('rxjs'), require('rxjs/operators'), require('query-string')) :
    typeof define === 'function' && define.amd ? define('angular-routing', ['exports', '@angular/core', '@angular/common', 'rxjs', 'rxjs/operators', 'query-string'], factory) :
    (global = global || self, factory(global['angular-routing'] = {}, global.ng.core, global.ng.common, global.rxjs, global.rxjs.operators, global.queryString));
}(this, (function (exports, core, common, rxjs, operators, queryString) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var UrlParser = /** @class */ (function () {
        function UrlParser() {
        }
        UrlParser.prototype.parse = function (url, base) {
            if (base) {
                return new URL(url, base);
            }
            return new URL(url);
        };
        UrlParser.prototype.joinUrls = function (currentUrl, url) {
            var currentUrlSegments = currentUrl
                .split('#')[0] // remove hash
                .split('?')[0] // remove query params
                .split('/');
            var urlSegments = url.split('/');
            return urlSegments
                .reduce(function (segments, segment) {
                if (segment === '.') {
                    return segments;
                }
                if (segment === '..') {
                    return segments.slice(0, -1);
                }
                return __spread(segments, [segment]);
            }, currentUrlSegments)
                .join('/');
        };
        UrlParser = __decorate([
            core.Injectable()
        ], UrlParser);
        return UrlParser;
    }());

    var RoutePath = /** @class */ (function (_super) {
        __extends(RoutePath, _super);
        function RoutePath() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return RoutePath;
    }(rxjs.Observable));
    var RouteParams = /** @class */ (function (_super) {
        __extends(RouteParams, _super);
        function RouteParams() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return RouteParams;
    }(rxjs.Observable));
    var QueryParams = /** @class */ (function (_super) {
        __extends(QueryParams, _super);
        function QueryParams() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return QueryParams;
    }(rxjs.Observable));
    function compareParams(previous, current) {
        return (previous === current || JSON.stringify(previous) === JSON.stringify(current));
    }

    var Router = /** @class */ (function () {
        function Router(location, platformLocation, urlParser) {
            var _this = this;
            this.location = location;
            this.platformLocation = platformLocation;
            this.urlParser = urlParser;
            this.state$ = new rxjs.BehaviorSubject({
                url: this.location.path(),
                queryParams: {},
                hash: '',
            });
            this.url$ = this.state$.pipe(operators.map(function (state) { return state.url; }), operators.distinctUntilChanged());
            this.hash$ = this.state$.pipe(operators.map(function (state) { return state.hash; }), operators.distinctUntilChanged());
            this.queryParams$ = this.state$.pipe(operators.map(function (state) { return state.queryParams; }), operators.distinctUntilChanged(compareParams));
            this.location.subscribe(function () {
                _this.nextState(_this.getLocation());
            });
            this.nextState(this.getLocation());
        }
        Router.prototype.go = function (url, queryParams, hash) {
            this.location.go(this.serializeUrl(url, queryParams, hash));
            this.nextState(this.getLocation());
        };
        Router.prototype.replace = function (url, queryParams, hash) {
            this.location.replaceState(this.serializeUrl(url, queryParams, hash));
            this.nextState(this.getLocation());
        };
        Router.prototype.serializeUrl = function (url, queryParams, hash) {
            // if relative path
            if (!url.startsWith('/')) {
                url = this.urlParser.joinUrls(this.location.path(), url);
            }
            return (url +
                (queryParams ? "?" + queryString.stringify(queryParams) : '') +
                ("" + (hash ? '#' + hash : '')));
        };
        Router.prototype.getExternalUrl = function (url) {
            return this.location.prepareExternalUrl(url);
        };
        Router.prototype.parseSearchParams = function (searchParams) {
            var queryParams = {};
            searchParams.forEach(function (value, key) {
                queryParams[key] = value;
            });
            return queryParams;
        };
        Router.prototype.normalizePath = function (path) {
            return this.location.normalize(path);
        };
        Router.prototype.getLocation = function () {
            return this.platformLocation.href;
        };
        Router.prototype.nextState = function (url) {
            var parsedUrl = this._parseUrl(url);
            this.state$.next({
                url: parsedUrl.pathname,
                queryParams: this.parseSearchParams(parsedUrl.searchParams),
                hash: parsedUrl.hash ? parsedUrl.hash.split('#')[0] : '',
            });
        };
        Router.prototype._parseUrl = function (path) {
            return this.urlParser.parse(path);
        };
        Router.ctorParameters = function () { return [
            { type: common.Location },
            { type: common.PlatformLocation },
            { type: UrlParser }
        ]; };
        Router.ɵprov = core.ɵɵdefineInjectable({ factory: function Router_Factory() { return new Router(core.ɵɵinject(common.Location), core.ɵɵinject(common.PlatformLocation), core.ɵɵinject(UrlParser)); }, token: Router, providedIn: "root" });
        Router = __decorate([
            core.Injectable({
                providedIn: 'root',
            }),
            __metadata("design:paramtypes", [common.Location,
                common.PlatformLocation,
                UrlParser])
        ], Router);
        return Router;
    }());

    var DEFAULT_TARGET = '_self';
    /**
     * The LinkTo directive links to routes in your app
     *
     * Links are pushed to the `Router` service to trigger a route change.
     * Query params can be represented as an object or a string of names/values
     *
     * <a linkTo="/home/page" [queryParams]="{ id: 123 }">Home Page</a>
     * <a [linkTo]="'/pages' + page.id">Page 1</a>
     */
    var LinkTo = /** @class */ (function () {
        function LinkTo(router) {
            this.router = router;
            this.target = DEFAULT_TARGET;
            this.hrefUpdated = new core.EventEmitter();
        }
        Object.defineProperty(LinkTo.prototype, "linkTo", {
            set: function (href) {
                this._href = href;
                this._updateHref();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LinkTo.prototype, "queryParams", {
            set: function (params) {
                this._query = params;
                this._updateHref();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LinkTo.prototype, "fragment", {
            set: function (hash) {
                this._hash = hash;
                this._updateHref();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Handles click events on the associated link
         * Prevents default action for non-combination click events without a target
         */
        LinkTo.prototype.onClick = function (event) {
            if (!this._comboClick(event) && this.target === DEFAULT_TARGET) {
                this.router.go(this._href, this._query, this._hash);
                event.preventDefault();
            }
        };
        LinkTo.prototype._updateHref = function () {
            var href = this._cleanUpHref(this._href);
            this.linkHref = this.router.serializeUrl(href, this._query, this._hash);
            this.hrefUpdated.emit(this.linkHref);
        };
        /**
         * Determines whether the click event happened with a combination of other keys
         */
        LinkTo.prototype._comboClick = function (event) {
            var buttonEvent = event.which || event.button;
            return buttonEvent > 1 || event.ctrlKey || event.metaKey || event.shiftKey;
        };
        LinkTo.prototype._cleanUpHref = function (href) {
            if (href === void 0) { href = ''; }
            // Trim whitespaces and remove trailing slashes
            return href.trim().replace(/[\/]+$/, '');
        };
        LinkTo.ctorParameters = function () { return [
            { type: Router }
        ]; };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], LinkTo.prototype, "target", void 0);
        __decorate([
            core.HostBinding('href'),
            __metadata("design:type", String)
        ], LinkTo.prototype, "linkHref", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], LinkTo.prototype, "linkTo", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], LinkTo.prototype, "queryParams", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], LinkTo.prototype, "fragment", null);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], LinkTo.prototype, "hrefUpdated", void 0);
        __decorate([
            core.HostListener('click', ['$event']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Object]),
            __metadata("design:returntype", void 0)
        ], LinkTo.prototype, "onClick", null);
        LinkTo = __decorate([
            core.Directive({ selector: 'a[linkTo]' }),
            __metadata("design:paramtypes", [Router])
        ], LinkTo);
        return LinkTo;
    }());

    var LINK_ACTIVE_OPTIONS = {
        exact: true,
    };
    /**
     * The LinkActive directive toggles classes on elements that contain an active linkTo directive
     *
     * <a linkActive="active" linkTo="/home/page">Home Page</a>
     * <ol>
     *  <li linkActive="active" *ngFor="var link of links">
     *    <a [linkTo]="'/link/' + link.id">{{ link.title }}</a>
     *  </li>
     * </ol>
     */
    var LinkActive = /** @class */ (function () {
        function LinkActive(element, router, renderer, defaultActiveOptions, link) {
            this.element = element;
            this.router = router;
            this.renderer = renderer;
            this.defaultActiveOptions = defaultActiveOptions;
            this.link = link;
            this.activeClass = 'active';
            this._activeOptions = { exact: true };
            this._destroy$ = new rxjs.Subject();
        }
        LinkActive.prototype.ngAfterContentInit = function () {
            var _this = this;
            if (this.defaultActiveOptions && !this.activeOptions) {
                this._activeOptions = this.defaultActiveOptions;
            }
            else if (this.activeOptions) {
                this._activeOptions = this.activeOptions;
            }
            this.links.changes.subscribe(function () { return _this.collectLinks(); });
            this.collectLinks();
        };
        LinkActive.prototype.ngOnChanges = function () {
            this.collectLinks();
        };
        LinkActive.prototype.collectLinks = function () {
            var _this = this;
            if (this._linksSub) {
                this._linksSub.unsubscribe();
            }
            var contentLinks$ = this.links
                ? this.links
                    .toArray()
                    .map(function (link) {
                    return link.hrefUpdated.pipe(operators.startWith(link.linkHref), operators.mapTo(link.linkHref));
                })
                : [];
            var link$ = this.link
                ? this.link.hrefUpdated.pipe(operators.startWith(this.link.linkHref), operators.mapTo(this.link.linkHref))
                : rxjs.of('');
            var router$ = this.router.url$.pipe(operators.map(function (path) { return _this.router.getExternalUrl(path || '/'); }));
            var observables$ = __spread([router$, link$], contentLinks$);
            this._linksSub = rxjs.combineLatest(observables$)
                .pipe(operators.takeUntil(this._destroy$))
                .subscribe(function (_a) {
                var _b = __read(_a), path = _b[0], link = _b[1], links = _b.slice(2);
                _this.checkActive(__spread(links, [link]), path);
            });
        };
        LinkActive.prototype.checkActive = function (linkHrefs, path) {
            var _this = this;
            var active = linkHrefs.reduce(function (isActive, current) {
                var _a = __read(current.split('?'), 1), href = _a[0];
                if (_this._activeOptions.exact) {
                    isActive = isActive ? isActive : href === path;
                }
                else {
                    isActive = isActive ? isActive : path.startsWith(href);
                }
                return isActive;
            }, false);
            this.updateClasses(active);
        };
        LinkActive.prototype.updateClasses = function (active) {
            var _this = this;
            var activeClasses = this.activeClass.split(' ');
            activeClasses.forEach(function (activeClass) {
                if (active) {
                    _this.renderer.addClass(_this.element.nativeElement, activeClass);
                }
                else {
                    _this.renderer.removeClass(_this.element.nativeElement, activeClass);
                }
            });
        };
        LinkActive.prototype.ngOnDestroy = function () {
            this._destroy$.next();
        };
        LinkActive.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: Router },
            { type: core.Renderer2 },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [LINK_ACTIVE_OPTIONS,] }] },
            { type: LinkTo, decorators: [{ type: core.Optional }] }
        ]; };
        __decorate([
            core.ContentChildren(LinkTo, { descendants: true }),
            __metadata("design:type", core.QueryList)
        ], LinkActive.prototype, "links", void 0);
        __decorate([
            core.Input('linkActive'),
            __metadata("design:type", Object)
        ], LinkActive.prototype, "activeClass", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], LinkActive.prototype, "activeOptions", void 0);
        LinkActive = __decorate([
            core.Directive({ selector: '[linkActive]' }),
            __param(3, core.Optional()),
            __param(3, core.Inject(LINK_ACTIVE_OPTIONS)),
            __param(4, core.Optional()),
            __metadata("design:paramtypes", [core.ElementRef,
                Router,
                core.Renderer2, Object, LinkTo])
        ], LinkActive);
        return LinkActive;
    }());

    var RouteComponentTemplate = /** @class */ (function () {
        function RouteComponentTemplate() {
        }
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RouteComponentTemplate.prototype, "routeComponent", void 0);
        RouteComponentTemplate = __decorate([
            core.Directive({
                selector: '[routeComponent]',
            })
        ], RouteComponentTemplate);
        return RouteComponentTemplate;
    }());

    var PARAM_PREFIX = ':';
    var DIV = '\\/'; // /
    var DIV_PARAM = "(?:" + DIV + "([^\\/#\\?]+?))"; // capturing group for one or more of not (/, # or ?), optional (TODO: check if optional is needed)
    var PATH_END = '[\\/#\\?]'; // path end: /, # or ?
    var END = '[]|$'; // null or end
    var EXACT_END = PATH_END + "?$"; // match PATH_END optionally and END
    var WILDCARD = "(?:" + PATH_END + "(?=" + END + "))?"; // match optionally PATH_END followed by END
    var NON_EXACT_END = WILDCARD + "(?=" + PATH_END + "|" + END + ")"; // match WILDCARD followed by PATH_END or END
    function getPathSegments(route) {
        var sanitizedPath = route.path.replace(/^\//, '').replace(/(?:\/$)/, '');
        return sanitizedPath ? sanitizedPath.split('/') : [];
    }
    var parsePath = function (route) {
        var _a;
        var segments = getPathSegments(route);
        var regexBody = segments.reduce(function (acc, segment) {
            return segment.startsWith(PARAM_PREFIX)
                ? "" + acc + DIV_PARAM
                : "" + acc + DIV + segment;
        }, '');
        if ((_a = route.options.exact) !== null && _a !== void 0 ? _a : true) {
            return new RegExp("^" + regexBody + EXACT_END, 'i');
        }
        else {
            return new RegExp("^" + regexBody + (regexBody ? NON_EXACT_END : WILDCARD), 'i');
        }
    };
    var matchRoute = function (url, route) {
        var _a;
        var match = (_a = route.matcher) === null || _a === void 0 ? void 0 : _a.exec(url);
        if (!match) {
            return;
        }
        var keys = getPathSegments(route)
            .filter(function (s) { return s.startsWith(PARAM_PREFIX); })
            .map(function (s) { return s.slice(1); });
        return {
            path: match[0],
            params: keys.reduce(function (acc, key, index) {
                var _a;
                return (__assign(__assign({}, acc), (_a = {}, _a[key] = match[index + 1], _a)));
            }, {}),
        };
    };

    /**
     * Compares two routes and returns sorting number
     * 0 - equal
     * -1 - `a` has priority over `b`
     * 1 - `b` has priority over `a`
     *
     * @param a Route
     * @param b Route
     */
    var compareRoutes = function (a, b) {
        var _a;
        // as matchers combine normalized path and `exact` option it's safe to compare regexps
        if (a.matcher.toString() === b.matcher.toString()) {
            return 0;
        }
        var aSegments = getPathSegments(a);
        var bSegments = getPathSegments(b);
        for (var i = 0; i < Math.max(aSegments.length, bSegments.length); i++) {
            var current = compareSegments(aSegments, bSegments, i);
            if (current) {
                return current;
            }
        }
        // when paths are same, exact has priority
        return ((_a = a.options.exact) !== null && _a !== void 0 ? _a : true) ? -1 : 1;
    };
    function compareSegments(aSegments, bSegments, index) {
        // if a has no more segments -> return 1
        if (aSegments.length <= index) {
            return 1;
        }
        // if b has no more segments -> return -1
        if (bSegments.length <= index) {
            return -1;
        }
        if (aSegments[index] === bSegments[index]) {
            return 0;
        }
        // prioritize non-empty path over empty
        if (!aSegments[index]) {
            return 1;
        }
        if (!bSegments[index]) {
            return -1;
        }
        // ignore param names
        if (isParam(aSegments[index]) && isParam(bSegments[index])) {
            return 0;
        }
        // static segment has priority over param
        if (isParam(aSegments[index])) {
            return 1;
        }
        if (isParam(bSegments[index])) {
            return -1;
        }
        // when all is same run string comparison
        return aSegments[index].localeCompare(bSegments[index]);
    }
    function isParam(segment) {
        return segment.startsWith(':');
    }

    var RouterComponent = /** @class */ (function () {
        // support multiple "routers"
        // router (base /)
        // blog(.*?)
        // router (base /blog)
        // post1(blog/post1/(.*?)
        // post2
        // post3
        function RouterComponent(router, parentRouterComponent) {
            this.router = router;
            this.parentRouterComponent = parentRouterComponent;
            this.destroy$ = new rxjs.Subject();
            this.state$ = new rxjs.BehaviorSubject({
                activeRoute: null,
                routes: [],
            });
            this.activeRoute$ = this.state$.pipe(operators.map(function (state) { return state.activeRoute; }), operators.distinctUntilChanged(this.compareActiveRoutes), operators.takeUntil(this.destroy$));
            this.routes$ = this.state$.pipe(operators.map(function (state) { return state.routes; }), operators.distinctUntilChanged(this.compareRoutes), operators.takeUntil(this.destroy$));
            this.basePath = '';
        }
        RouterComponent.prototype.ngOnInit = function () {
            var _this = this;
            rxjs.combineLatest([this.routes$.pipe(operators.debounceTime(1)), this.router.url$])
                .pipe(operators.distinctUntilChanged(), operators.tap(function (_a) {
                var e_1, _b;
                var _c = __read(_a, 2), routes = _c[0], url = _c[1];
                var routeToRender = null;
                try {
                    for (var routes_1 = __values(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {
                        var route = routes_1_1.value;
                        routeToRender = _this.isRouteMatch(url, route);
                        if (routeToRender) {
                            _this.setRoute(url, route);
                            break;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (routes_1_1 && !routes_1_1.done && (_b = routes_1.return)) _b.call(routes_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                if (!routeToRender) {
                    _this.setActiveRoute({ route: null, params: {}, path: '' });
                }
            }), operators.takeUntil(this.destroy$))
                .subscribe();
        };
        RouterComponent.prototype.setRoute = function (url, route) {
            this.basePath = route.path;
            var match = matchRoute(url, route);
            this.setActiveRoute({
                route: route,
                params: (match === null || match === void 0 ? void 0 : match.params) || {},
                path: (match === null || match === void 0 ? void 0 : match.path) || '',
            });
        };
        RouterComponent.prototype.registerRoute = function (route) {
            route.matcher = route.matcher || parsePath(route);
            this.updateRoutes(route);
            return route;
        };
        RouterComponent.prototype.setActiveRoute = function (activeRoute) {
            this.updateState({ activeRoute: activeRoute });
        };
        RouterComponent.prototype.unregisterRoute = function (route) {
            this.updateRoutes(__assign(__assign({}, route), { unregister: true }));
        };
        RouterComponent.prototype.normalizePath = function (path) {
            return this.router.normalizePath(path);
        };
        RouterComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next();
        };
        RouterComponent.prototype.isRouteMatch = function (url, route) {
            var _a;
            return (_a = route.matcher) === null || _a === void 0 ? void 0 : _a.exec(url);
        };
        RouterComponent.prototype.compareActiveRoutes = function (previous, current) {
            if (previous === current) {
                return true;
            }
            if (!previous) {
                return false;
            }
            return (previous.path === current.path &&
                compareParams(previous.params, current.params) &&
                previous.route.path === current.route.path &&
                previous.route.options.exact === current.route.options.exact);
        };
        RouterComponent.prototype.compareRoutes = function (previous, current) {
            if (previous === current) {
                return true;
            }
            if (!previous) {
                return false;
            }
            return (previous.length === current.length &&
                previous.every(function (route, i) { return route[i] === current[i]; }));
        };
        RouterComponent.prototype.updateState = function (newState) {
            this.state$.next(__assign(__assign({}, this.state$.value), newState));
        };
        RouterComponent.prototype.updateRoutes = function (route) {
            var routes = this.state$.value.routes;
            if (route.unregister) {
                this.updateState({
                    routes: routes.filter(function (r) { return r.matcher !== route.matcher; }),
                });
            }
            else {
                this.updateState({ routes: routes.concat(route).sort(compareRoutes) });
            }
        };
        RouterComponent.ctorParameters = function () { return [
            { type: Router },
            { type: RouterComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }] }
        ]; };
        RouterComponent = __decorate([
            core.Component({
                // tslint:disable-next-line:component-selector
                selector: 'router',
                template: '<ng-content></ng-content>'
            }),
            __param(1, core.SkipSelf()), __param(1, core.Optional()),
            __metadata("design:paramtypes", [Router,
                RouterComponent])
        ], RouterComponent);
        return RouterComponent;
    }());

    function getRouteParams(routeComponent) {
        return routeComponent.routeParams$;
    }
    function getRoutePath(routeComponent) {
        return routeComponent.routePath$;
    }
    var RouteComponent = /** @class */ (function () {
        function RouteComponent(router, routerComponent, resolver, viewContainerRef, compiler) {
            this.router = router;
            this.routerComponent = routerComponent;
            this.resolver = resolver;
            this.viewContainerRef = viewContainerRef;
            this.compiler = compiler;
            this.reuse = true;
            this.destroy$ = new rxjs.Subject();
            this.state$ = new rxjs.BehaviorSubject({
                params: {},
                path: '',
                shouldRender: false,
            });
            this.shouldRender$ = this.state$.pipe(operators.map(function (state) { return state.shouldRender; }));
            this.routeParams$ = this.state$.pipe(operators.map(function (state) { return state.params; }), operators.distinctUntilChanged(), operators.takeUntil(this.destroy$));
            this.routePath$ = this.state$.pipe(operators.map(function (state) { return state.path; }), operators.distinctUntilChanged(), operators.takeUntil(this.destroy$));
        }
        RouteComponent_1 = RouteComponent;
        Object.defineProperty(RouteComponent.prototype, "path", {
            get: function () {
                return this._path;
            },
            set: function (value) {
                this._path = this.sanitizePath(value);
            },
            enumerable: true,
            configurable: true
        });
        RouteComponent.prototype.ngOnInit = function () {
            var _this = this;
            // account for root level routes, don't add the basePath
            var path = this.routerComponent.parentRouterComponent
                ? this.routerComponent.parentRouterComponent.basePath + this.path
                : this.path;
            this.route = this.registerRoute(path, this.exact, this.load);
            this.routerComponent.activeRoute$
                .pipe(operators.filter(function (ar) { return ar !== null; }), operators.distinctUntilChanged(), operators.withLatestFrom(this.shouldRender$), operators.mergeMap(function (_a) {
                var _b = __read(_a, 2), current = _b[0], rendered = _b[1];
                if (current.route === _this.route) {
                    if (_this.redirectTo) {
                        _this.router.go(_this.redirectTo);
                        return rxjs.of(null);
                    }
                    _this.updateState({
                        params: current.params,
                        path: current.path,
                    });
                    if (!rendered) {
                        if (!_this.reuse) {
                            _this.clearView();
                        }
                        return _this.loadAndRender(current.route);
                    }
                    return rxjs.of(null);
                }
                else if (rendered) {
                    return rxjs.of(_this.clearView());
                }
                return rxjs.of(null);
            }), operators.takeUntil(this.destroy$))
                .subscribe();
        };
        RouteComponent.prototype.ngOnDestroy = function () {
            this.routerComponent.unregisterRoute(this.route);
            this.destroy$.next();
        };
        RouteComponent.prototype.registerRoute = function (path, exact, load) {
            return this.routerComponent.registerRoute({
                path: path,
                load: load,
                options: this.routeOptions || { exact: exact },
            });
        };
        RouteComponent.prototype.loadAndRender = function (route) {
            var _this = this;
            if (route.load) {
                return rxjs.from(route.load().then(function (componentOrModule) {
                    if (componentOrModule instanceof core.NgModuleFactory) {
                        var moduleRef = componentOrModule.create(_this.viewContainerRef.injector);
                        var component = moduleRef.instance.routeComponent;
                        _this.renderComponent(component);
                    }
                    else if (componentOrModule.ɵmod) {
                        return _this.compiler
                            .compileModuleAsync(componentOrModule)
                            .then(function (moduleFactory) {
                            var moduleRef = moduleFactory.create(_this.viewContainerRef.injector);
                            var component = moduleRef.instance.routeComponent;
                            _this.renderComponent(component);
                            return true;
                        });
                    }
                    else {
                        _this.renderComponent(componentOrModule);
                    }
                    return true;
                }));
            }
            else {
                this.showTemplate();
                return rxjs.of(true);
            }
        };
        RouteComponent.prototype.renderComponent = function (component) {
            var componentFactory = this.resolver.resolveComponentFactory(component);
            this.showTemplate();
            this.viewContainerRef.createComponent(componentFactory, this.viewContainerRef.length, this.viewContainerRef.injector);
        };
        RouteComponent.prototype.clearComponent = function () {
            this.viewContainerRef.clear();
            this.hideTemplate();
        };
        RouteComponent.prototype.showTemplate = function () {
            var _this = this;
            setTimeout(function () {
                _this.updateState({ shouldRender: true });
            });
        };
        RouteComponent.prototype.hideTemplate = function () {
            this.updateState({ shouldRender: false });
        };
        RouteComponent.prototype.clearView = function () {
            if (this.load) {
                this.clearComponent();
            }
            else {
                this.hideTemplate();
            }
        };
        RouteComponent.prototype.sanitizePath = function (path) {
            var trimmed = path.trim();
            return trimmed.startsWith('/') ? trimmed : "/" + trimmed;
        };
        RouteComponent.prototype.updateState = function (newState) {
            this.state$.next(__assign(__assign({}, this.state$.value), newState));
        };
        var RouteComponent_1;
        RouteComponent.ctorParameters = function () { return [
            { type: Router },
            { type: RouterComponent },
            { type: core.ComponentFactoryResolver },
            { type: core.ViewContainerRef },
            { type: core.Compiler }
        ]; };
        __decorate([
            core.ContentChild(core.TemplateRef),
            __metadata("design:type", core.TemplateRef)
        ], RouteComponent.prototype, "template", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], RouteComponent.prototype, "path", null);
        __decorate([
            core.Input(),
            __metadata("design:type", core.Type)
        ], RouteComponent.prototype, "component", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], RouteComponent.prototype, "load", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RouteComponent.prototype, "reuse", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RouteComponent.prototype, "redirectTo", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], RouteComponent.prototype, "exact", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RouteComponent.prototype, "routeOptions", void 0);
        RouteComponent = RouteComponent_1 = __decorate([
            core.Component({
                // tslint:disable-next-line:component-selector
                selector: 'route',
                template: "\n    <ng-container\n      *ngIf=\"(shouldRender$ | async) && template\"\n      [ngTemplateOutlet]=\"template\"\n    >\n    </ng-container>\n  ",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: RouteParams,
                        useFactory: getRouteParams,
                        deps: [[new core.Self(), RouteComponent_1]],
                    },
                    {
                        provide: RoutePath,
                        useFactory: getRoutePath,
                        deps: [[new core.Self(), RouteComponent_1]],
                    },
                ]
            }),
            __metadata("design:paramtypes", [Router,
                RouterComponent,
                core.ComponentFactoryResolver,
                core.ViewContainerRef,
                core.Compiler])
        ], RouteComponent);
        return RouteComponent;
    }());

    var components = [
        RouterComponent,
        RouteComponent,
        LinkActive,
        LinkTo,
        RouteComponentTemplate,
    ];
    function getQueryParams(router) {
        return router.queryParams$;
    }
    var RoutingModule = /** @class */ (function () {
        function RoutingModule() {
        }
        RoutingModule_1 = RoutingModule;
        RoutingModule.forRoot = function () {
            return {
                ngModule: RoutingModule_1,
                providers: [
                    UrlParser,
                    { provide: common.LocationStrategy, useClass: common.PathLocationStrategy },
                    { provide: QueryParams, deps: [Router], useFactory: getQueryParams },
                ],
            };
        };
        var RoutingModule_1;
        RoutingModule = RoutingModule_1 = __decorate([
            core.NgModule({
                imports: [common.CommonModule],
                declarations: [components],
                exports: [components],
            })
        ], RoutingModule);
        return RoutingModule;
    }());

    exports.LINK_ACTIVE_OPTIONS = LINK_ACTIVE_OPTIONS;
    exports.LinkActive = LinkActive;
    exports.LinkTo = LinkTo;
    exports.QueryParams = QueryParams;
    exports.RouteComponent = RouteComponent;
    exports.RouteComponentTemplate = RouteComponentTemplate;
    exports.RouteParams = RouteParams;
    exports.RoutePath = RoutePath;
    exports.Router = Router;
    exports.RouterComponent = RouterComponent;
    exports.RoutingModule = RoutingModule;
    exports.UrlParser = UrlParser;
    exports.compareParams = compareParams;
    exports.components = components;
    exports.getQueryParams = getQueryParams;
    exports.getRouteParams = getRouteParams;
    exports.getRoutePath = getRoutePath;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=angular-routing.umd.js.map
