import { __spread, __decorate, __extends, __metadata, __read, __param, __assign, __values } from 'tslib';
import { Injectable, ɵɵdefineInjectable, ɵɵinject, EventEmitter, Input, HostBinding, Output, HostListener, Directive, ElementRef, Renderer2, Optional, Inject, ContentChildren, QueryList, SkipSelf, Component, NgModuleFactory, ComponentFactoryResolver, ViewContainerRef, Compiler, ContentChild, TemplateRef, Type, ChangeDetectionStrategy, Self, NgModule } from '@angular/core';
import { Location, PlatformLocation, LocationStrategy, PathLocationStrategy, CommonModule } from '@angular/common';
import { Observable, BehaviorSubject, Subject, of, combineLatest, from } from 'rxjs';
import { map, distinctUntilChanged, startWith, mapTo, takeUntil, debounceTime, tap, filter, withLatestFrom, mergeMap } from 'rxjs/operators';
import { stringify } from 'query-string';

var UrlParser = /** @class */ (function () {
    function UrlParser() {
    }
    UrlParser.prototype.parse = function (url, base) {
        if (base) {
            return new URL(url, base);
        }
        return new URL(url);
    };
    UrlParser.prototype.joinUrls = function (currentUrl, url) {
        var currentUrlSegments = currentUrl
            .split('#')[0] // remove hash
            .split('?')[0] // remove query params
            .split('/');
        var urlSegments = url.split('/');
        return urlSegments
            .reduce(function (segments, segment) {
            if (segment === '.') {
                return segments;
            }
            if (segment === '..') {
                return segments.slice(0, -1);
            }
            return __spread(segments, [segment]);
        }, currentUrlSegments)
            .join('/');
    };
    UrlParser = __decorate([
        Injectable()
    ], UrlParser);
    return UrlParser;
}());

var RoutePath = /** @class */ (function (_super) {
    __extends(RoutePath, _super);
    function RoutePath() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return RoutePath;
}(Observable));
var RouteParams = /** @class */ (function (_super) {
    __extends(RouteParams, _super);
    function RouteParams() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return RouteParams;
}(Observable));
var QueryParams = /** @class */ (function (_super) {
    __extends(QueryParams, _super);
    function QueryParams() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueryParams;
}(Observable));
function compareParams(previous, current) {
    return (previous === current || JSON.stringify(previous) === JSON.stringify(current));
}

var Router = /** @class */ (function () {
    function Router(location, platformLocation, urlParser) {
        var _this = this;
        this.location = location;
        this.platformLocation = platformLocation;
        this.urlParser = urlParser;
        this.state$ = new BehaviorSubject({
            url: this.location.path(),
            queryParams: {},
            hash: '',
        });
        this.url$ = this.state$.pipe(map(function (state) { return state.url; }), distinctUntilChanged());
        this.hash$ = this.state$.pipe(map(function (state) { return state.hash; }), distinctUntilChanged());
        this.queryParams$ = this.state$.pipe(map(function (state) { return state.queryParams; }), distinctUntilChanged(compareParams));
        this.location.subscribe(function () {
            _this.nextState(_this.getLocation());
        });
        this.nextState(this.getLocation());
    }
    Router.prototype.go = function (url, queryParams, hash) {
        this.location.go(this.serializeUrl(url, queryParams, hash));
        this.nextState(this.getLocation());
    };
    Router.prototype.replace = function (url, queryParams, hash) {
        this.location.replaceState(this.serializeUrl(url, queryParams, hash));
        this.nextState(this.getLocation());
    };
    Router.prototype.serializeUrl = function (url, queryParams, hash) {
        // if relative path
        if (!url.startsWith('/')) {
            url = this.urlParser.joinUrls(this.location.path(), url);
        }
        return (url +
            (queryParams ? "?" + stringify(queryParams) : '') +
            ("" + (hash ? '#' + hash : '')));
    };
    Router.prototype.getExternalUrl = function (url) {
        return this.location.prepareExternalUrl(url);
    };
    Router.prototype.parseSearchParams = function (searchParams) {
        var queryParams = {};
        searchParams.forEach(function (value, key) {
            queryParams[key] = value;
        });
        return queryParams;
    };
    Router.prototype.normalizePath = function (path) {
        return this.location.normalize(path);
    };
    Router.prototype.getLocation = function () {
        return this.platformLocation.href;
    };
    Router.prototype.nextState = function (url) {
        var parsedUrl = this._parseUrl(url);
        this.state$.next({
            url: parsedUrl.pathname,
            queryParams: this.parseSearchParams(parsedUrl.searchParams),
            hash: parsedUrl.hash ? parsedUrl.hash.split('#')[0] : '',
        });
    };
    Router.prototype._parseUrl = function (path) {
        return this.urlParser.parse(path);
    };
    Router.ctorParameters = function () { return [
        { type: Location },
        { type: PlatformLocation },
        { type: UrlParser }
    ]; };
    Router.ɵprov = ɵɵdefineInjectable({ factory: function Router_Factory() { return new Router(ɵɵinject(Location), ɵɵinject(PlatformLocation), ɵɵinject(UrlParser)); }, token: Router, providedIn: "root" });
    Router = __decorate([
        Injectable({
            providedIn: 'root',
        }),
        __metadata("design:paramtypes", [Location,
            PlatformLocation,
            UrlParser])
    ], Router);
    return Router;
}());

var DEFAULT_TARGET = '_self';
/**
 * The LinkTo directive links to routes in your app
 *
 * Links are pushed to the `Router` service to trigger a route change.
 * Query params can be represented as an object or a string of names/values
 *
 * <a linkTo="/home/page" [queryParams]="{ id: 123 }">Home Page</a>
 * <a [linkTo]="'/pages' + page.id">Page 1</a>
 */
var LinkTo = /** @class */ (function () {
    function LinkTo(router) {
        this.router = router;
        this.target = DEFAULT_TARGET;
        this.hrefUpdated = new EventEmitter();
    }
    Object.defineProperty(LinkTo.prototype, "linkTo", {
        set: function (href) {
            this._href = href;
            this._updateHref();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinkTo.prototype, "queryParams", {
        set: function (params) {
            this._query = params;
            this._updateHref();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinkTo.prototype, "fragment", {
        set: function (hash) {
            this._hash = hash;
            this._updateHref();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handles click events on the associated link
     * Prevents default action for non-combination click events without a target
     */
    LinkTo.prototype.onClick = function (event) {
        if (!this._comboClick(event) && this.target === DEFAULT_TARGET) {
            this.router.go(this._href, this._query, this._hash);
            event.preventDefault();
        }
    };
    LinkTo.prototype._updateHref = function () {
        var href = this._cleanUpHref(this._href);
        this.linkHref = this.router.serializeUrl(href, this._query, this._hash);
        this.hrefUpdated.emit(this.linkHref);
    };
    /**
     * Determines whether the click event happened with a combination of other keys
     */
    LinkTo.prototype._comboClick = function (event) {
        var buttonEvent = event.which || event.button;
        return buttonEvent > 1 || event.ctrlKey || event.metaKey || event.shiftKey;
    };
    LinkTo.prototype._cleanUpHref = function (href) {
        if (href === void 0) { href = ''; }
        // Trim whitespaces and remove trailing slashes
        return href.trim().replace(/[\/]+$/, '');
    };
    LinkTo.ctorParameters = function () { return [
        { type: Router }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LinkTo.prototype, "target", void 0);
    __decorate([
        HostBinding('href'),
        __metadata("design:type", String)
    ], LinkTo.prototype, "linkHref", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], LinkTo.prototype, "linkTo", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], LinkTo.prototype, "queryParams", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], LinkTo.prototype, "fragment", null);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], LinkTo.prototype, "hrefUpdated", void 0);
    __decorate([
        HostListener('click', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], LinkTo.prototype, "onClick", null);
    LinkTo = __decorate([
        Directive({ selector: 'a[linkTo]' }),
        __metadata("design:paramtypes", [Router])
    ], LinkTo);
    return LinkTo;
}());

var LINK_ACTIVE_OPTIONS = {
    exact: true,
};
/**
 * The LinkActive directive toggles classes on elements that contain an active linkTo directive
 *
 * <a linkActive="active" linkTo="/home/page">Home Page</a>
 * <ol>
 *  <li linkActive="active" *ngFor="var link of links">
 *    <a [linkTo]="'/link/' + link.id">{{ link.title }}</a>
 *  </li>
 * </ol>
 */
var LinkActive = /** @class */ (function () {
    function LinkActive(element, router, renderer, defaultActiveOptions, link) {
        this.element = element;
        this.router = router;
        this.renderer = renderer;
        this.defaultActiveOptions = defaultActiveOptions;
        this.link = link;
        this.activeClass = 'active';
        this._activeOptions = { exact: true };
        this._destroy$ = new Subject();
    }
    LinkActive.prototype.ngAfterContentInit = function () {
        var _this = this;
        if (this.defaultActiveOptions && !this.activeOptions) {
            this._activeOptions = this.defaultActiveOptions;
        }
        else if (this.activeOptions) {
            this._activeOptions = this.activeOptions;
        }
        this.links.changes.subscribe(function () { return _this.collectLinks(); });
        this.collectLinks();
    };
    LinkActive.prototype.ngOnChanges = function () {
        this.collectLinks();
    };
    LinkActive.prototype.collectLinks = function () {
        var _this = this;
        if (this._linksSub) {
            this._linksSub.unsubscribe();
        }
        var contentLinks$ = this.links
            ? this.links
                .toArray()
                .map(function (link) {
                return link.hrefUpdated.pipe(startWith(link.linkHref), mapTo(link.linkHref));
            })
            : [];
        var link$ = this.link
            ? this.link.hrefUpdated.pipe(startWith(this.link.linkHref), mapTo(this.link.linkHref))
            : of('');
        var router$ = this.router.url$.pipe(map(function (path) { return _this.router.getExternalUrl(path || '/'); }));
        var observables$ = __spread([router$, link$], contentLinks$);
        this._linksSub = combineLatest(observables$)
            .pipe(takeUntil(this._destroy$))
            .subscribe(function (_a) {
            var _b = __read(_a), path = _b[0], link = _b[1], links = _b.slice(2);
            _this.checkActive(__spread(links, [link]), path);
        });
    };
    LinkActive.prototype.checkActive = function (linkHrefs, path) {
        var _this = this;
        var active = linkHrefs.reduce(function (isActive, current) {
            var _a = __read(current.split('?'), 1), href = _a[0];
            if (_this._activeOptions.exact) {
                isActive = isActive ? isActive : href === path;
            }
            else {
                isActive = isActive ? isActive : path.startsWith(href);
            }
            return isActive;
        }, false);
        this.updateClasses(active);
    };
    LinkActive.prototype.updateClasses = function (active) {
        var _this = this;
        var activeClasses = this.activeClass.split(' ');
        activeClasses.forEach(function (activeClass) {
            if (active) {
                _this.renderer.addClass(_this.element.nativeElement, activeClass);
            }
            else {
                _this.renderer.removeClass(_this.element.nativeElement, activeClass);
            }
        });
    };
    LinkActive.prototype.ngOnDestroy = function () {
        this._destroy$.next();
    };
    LinkActive.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Router },
        { type: Renderer2 },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LINK_ACTIVE_OPTIONS,] }] },
        { type: LinkTo, decorators: [{ type: Optional }] }
    ]; };
    __decorate([
        ContentChildren(LinkTo, { descendants: true }),
        __metadata("design:type", QueryList)
    ], LinkActive.prototype, "links", void 0);
    __decorate([
        Input('linkActive'),
        __metadata("design:type", Object)
    ], LinkActive.prototype, "activeClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LinkActive.prototype, "activeOptions", void 0);
    LinkActive = __decorate([
        Directive({ selector: '[linkActive]' }),
        __param(3, Optional()),
        __param(3, Inject(LINK_ACTIVE_OPTIONS)),
        __param(4, Optional()),
        __metadata("design:paramtypes", [ElementRef,
            Router,
            Renderer2, Object, LinkTo])
    ], LinkActive);
    return LinkActive;
}());

var RouteComponentTemplate = /** @class */ (function () {
    function RouteComponentTemplate() {
    }
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], RouteComponentTemplate.prototype, "routeComponent", void 0);
    RouteComponentTemplate = __decorate([
        Directive({
            selector: '[routeComponent]',
        })
    ], RouteComponentTemplate);
    return RouteComponentTemplate;
}());

var PARAM_PREFIX = ':';
var DIV = '\\/'; // /
var DIV_PARAM = "(?:" + DIV + "([^\\/#\\?]+?))"; // capturing group for one or more of not (/, # or ?), optional (TODO: check if optional is needed)
var PATH_END = '[\\/#\\?]'; // path end: /, # or ?
var END = '[]|$'; // null or end
var EXACT_END = PATH_END + "?$"; // match PATH_END optionally and END
var WILDCARD = "(?:" + PATH_END + "(?=" + END + "))?"; // match optionally PATH_END followed by END
var NON_EXACT_END = WILDCARD + "(?=" + PATH_END + "|" + END + ")"; // match WILDCARD followed by PATH_END or END
function getPathSegments(route) {
    var sanitizedPath = route.path.replace(/^\//, '').replace(/(?:\/$)/, '');
    return sanitizedPath ? sanitizedPath.split('/') : [];
}
var parsePath = function (route) {
    var _a;
    var segments = getPathSegments(route);
    var regexBody = segments.reduce(function (acc, segment) {
        return segment.startsWith(PARAM_PREFIX)
            ? "" + acc + DIV_PARAM
            : "" + acc + DIV + segment;
    }, '');
    if ((_a = route.options.exact) !== null && _a !== void 0 ? _a : true) {
        return new RegExp("^" + regexBody + EXACT_END, 'i');
    }
    else {
        return new RegExp("^" + regexBody + (regexBody ? NON_EXACT_END : WILDCARD), 'i');
    }
};
var matchRoute = function (url, route) {
    var _a;
    var match = (_a = route.matcher) === null || _a === void 0 ? void 0 : _a.exec(url);
    if (!match) {
        return;
    }
    var keys = getPathSegments(route)
        .filter(function (s) { return s.startsWith(PARAM_PREFIX); })
        .map(function (s) { return s.slice(1); });
    return {
        path: match[0],
        params: keys.reduce(function (acc, key, index) {
            var _a;
            return (__assign(__assign({}, acc), (_a = {}, _a[key] = match[index + 1], _a)));
        }, {}),
    };
};

/**
 * Compares two routes and returns sorting number
 * 0 - equal
 * -1 - `a` has priority over `b`
 * 1 - `b` has priority over `a`
 *
 * @param a Route
 * @param b Route
 */
var compareRoutes = function (a, b) {
    var _a;
    // as matchers combine normalized path and `exact` option it's safe to compare regexps
    if (a.matcher.toString() === b.matcher.toString()) {
        return 0;
    }
    var aSegments = getPathSegments(a);
    var bSegments = getPathSegments(b);
    for (var i = 0; i < Math.max(aSegments.length, bSegments.length); i++) {
        var current = compareSegments(aSegments, bSegments, i);
        if (current) {
            return current;
        }
    }
    // when paths are same, exact has priority
    return ((_a = a.options.exact) !== null && _a !== void 0 ? _a : true) ? -1 : 1;
};
function compareSegments(aSegments, bSegments, index) {
    // if a has no more segments -> return 1
    if (aSegments.length <= index) {
        return 1;
    }
    // if b has no more segments -> return -1
    if (bSegments.length <= index) {
        return -1;
    }
    if (aSegments[index] === bSegments[index]) {
        return 0;
    }
    // prioritize non-empty path over empty
    if (!aSegments[index]) {
        return 1;
    }
    if (!bSegments[index]) {
        return -1;
    }
    // ignore param names
    if (isParam(aSegments[index]) && isParam(bSegments[index])) {
        return 0;
    }
    // static segment has priority over param
    if (isParam(aSegments[index])) {
        return 1;
    }
    if (isParam(bSegments[index])) {
        return -1;
    }
    // when all is same run string comparison
    return aSegments[index].localeCompare(bSegments[index]);
}
function isParam(segment) {
    return segment.startsWith(':');
}

var RouterComponent = /** @class */ (function () {
    // support multiple "routers"
    // router (base /)
    // blog(.*?)
    // router (base /blog)
    // post1(blog/post1/(.*?)
    // post2
    // post3
    function RouterComponent(router, parentRouterComponent) {
        this.router = router;
        this.parentRouterComponent = parentRouterComponent;
        this.destroy$ = new Subject();
        this.state$ = new BehaviorSubject({
            activeRoute: null,
            routes: [],
        });
        this.activeRoute$ = this.state$.pipe(map(function (state) { return state.activeRoute; }), distinctUntilChanged(this.compareActiveRoutes), takeUntil(this.destroy$));
        this.routes$ = this.state$.pipe(map(function (state) { return state.routes; }), distinctUntilChanged(this.compareRoutes), takeUntil(this.destroy$));
        this.basePath = '';
    }
    RouterComponent.prototype.ngOnInit = function () {
        var _this = this;
        combineLatest([this.routes$.pipe(debounceTime(1)), this.router.url$])
            .pipe(distinctUntilChanged(), tap(function (_a) {
            var e_1, _b;
            var _c = __read(_a, 2), routes = _c[0], url = _c[1];
            var routeToRender = null;
            try {
                for (var routes_1 = __values(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {
                    var route = routes_1_1.value;
                    routeToRender = _this.isRouteMatch(url, route);
                    if (routeToRender) {
                        _this.setRoute(url, route);
                        break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (routes_1_1 && !routes_1_1.done && (_b = routes_1.return)) _b.call(routes_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (!routeToRender) {
                _this.setActiveRoute({ route: null, params: {}, path: '' });
            }
        }), takeUntil(this.destroy$))
            .subscribe();
    };
    RouterComponent.prototype.setRoute = function (url, route) {
        this.basePath = route.path;
        var match = matchRoute(url, route);
        this.setActiveRoute({
            route: route,
            params: (match === null || match === void 0 ? void 0 : match.params) || {},
            path: (match === null || match === void 0 ? void 0 : match.path) || '',
        });
    };
    RouterComponent.prototype.registerRoute = function (route) {
        route.matcher = route.matcher || parsePath(route);
        this.updateRoutes(route);
        return route;
    };
    RouterComponent.prototype.setActiveRoute = function (activeRoute) {
        this.updateState({ activeRoute: activeRoute });
    };
    RouterComponent.prototype.unregisterRoute = function (route) {
        this.updateRoutes(__assign(__assign({}, route), { unregister: true }));
    };
    RouterComponent.prototype.normalizePath = function (path) {
        return this.router.normalizePath(path);
    };
    RouterComponent.prototype.ngOnDestroy = function () {
        this.destroy$.next();
    };
    RouterComponent.prototype.isRouteMatch = function (url, route) {
        var _a;
        return (_a = route.matcher) === null || _a === void 0 ? void 0 : _a.exec(url);
    };
    RouterComponent.prototype.compareActiveRoutes = function (previous, current) {
        if (previous === current) {
            return true;
        }
        if (!previous) {
            return false;
        }
        return (previous.path === current.path &&
            compareParams(previous.params, current.params) &&
            previous.route.path === current.route.path &&
            previous.route.options.exact === current.route.options.exact);
    };
    RouterComponent.prototype.compareRoutes = function (previous, current) {
        if (previous === current) {
            return true;
        }
        if (!previous) {
            return false;
        }
        return (previous.length === current.length &&
            previous.every(function (route, i) { return route[i] === current[i]; }));
    };
    RouterComponent.prototype.updateState = function (newState) {
        this.state$.next(__assign(__assign({}, this.state$.value), newState));
    };
    RouterComponent.prototype.updateRoutes = function (route) {
        var routes = this.state$.value.routes;
        if (route.unregister) {
            this.updateState({
                routes: routes.filter(function (r) { return r.matcher !== route.matcher; }),
            });
        }
        else {
            this.updateState({ routes: routes.concat(route).sort(compareRoutes) });
        }
    };
    RouterComponent.ctorParameters = function () { return [
        { type: Router },
        { type: RouterComponent, decorators: [{ type: SkipSelf }, { type: Optional }] }
    ]; };
    RouterComponent = __decorate([
        Component({
            // tslint:disable-next-line:component-selector
            selector: 'router',
            template: '<ng-content></ng-content>'
        }),
        __param(1, SkipSelf()), __param(1, Optional()),
        __metadata("design:paramtypes", [Router,
            RouterComponent])
    ], RouterComponent);
    return RouterComponent;
}());

function getRouteParams(routeComponent) {
    return routeComponent.routeParams$;
}
function getRoutePath(routeComponent) {
    return routeComponent.routePath$;
}
var RouteComponent = /** @class */ (function () {
    function RouteComponent(router, routerComponent, resolver, viewContainerRef, compiler) {
        this.router = router;
        this.routerComponent = routerComponent;
        this.resolver = resolver;
        this.viewContainerRef = viewContainerRef;
        this.compiler = compiler;
        this.reuse = true;
        this.destroy$ = new Subject();
        this.state$ = new BehaviorSubject({
            params: {},
            path: '',
            shouldRender: false,
        });
        this.shouldRender$ = this.state$.pipe(map(function (state) { return state.shouldRender; }));
        this.routeParams$ = this.state$.pipe(map(function (state) { return state.params; }), distinctUntilChanged(), takeUntil(this.destroy$));
        this.routePath$ = this.state$.pipe(map(function (state) { return state.path; }), distinctUntilChanged(), takeUntil(this.destroy$));
    }
    RouteComponent_1 = RouteComponent;
    Object.defineProperty(RouteComponent.prototype, "path", {
        get: function () {
            return this._path;
        },
        set: function (value) {
            this._path = this.sanitizePath(value);
        },
        enumerable: true,
        configurable: true
    });
    RouteComponent.prototype.ngOnInit = function () {
        var _this = this;
        // account for root level routes, don't add the basePath
        var path = this.routerComponent.parentRouterComponent
            ? this.routerComponent.parentRouterComponent.basePath + this.path
            : this.path;
        this.route = this.registerRoute(path, this.exact, this.load);
        this.routerComponent.activeRoute$
            .pipe(filter(function (ar) { return ar !== null; }), distinctUntilChanged(), withLatestFrom(this.shouldRender$), mergeMap(function (_a) {
            var _b = __read(_a, 2), current = _b[0], rendered = _b[1];
            if (current.route === _this.route) {
                if (_this.redirectTo) {
                    _this.router.go(_this.redirectTo);
                    return of(null);
                }
                _this.updateState({
                    params: current.params,
                    path: current.path,
                });
                if (!rendered) {
                    if (!_this.reuse) {
                        _this.clearView();
                    }
                    return _this.loadAndRender(current.route);
                }
                return of(null);
            }
            else if (rendered) {
                return of(_this.clearView());
            }
            return of(null);
        }), takeUntil(this.destroy$))
            .subscribe();
    };
    RouteComponent.prototype.ngOnDestroy = function () {
        this.routerComponent.unregisterRoute(this.route);
        this.destroy$.next();
    };
    RouteComponent.prototype.registerRoute = function (path, exact, load) {
        return this.routerComponent.registerRoute({
            path: path,
            load: load,
            options: this.routeOptions || { exact: exact },
        });
    };
    RouteComponent.prototype.loadAndRender = function (route) {
        var _this = this;
        if (route.load) {
            return from(route.load().then(function (componentOrModule) {
                if (componentOrModule instanceof NgModuleFactory) {
                    var moduleRef = componentOrModule.create(_this.viewContainerRef.injector);
                    var component = moduleRef.instance.routeComponent;
                    _this.renderComponent(component);
                }
                else if (componentOrModule.ɵmod) {
                    return _this.compiler
                        .compileModuleAsync(componentOrModule)
                        .then(function (moduleFactory) {
                        var moduleRef = moduleFactory.create(_this.viewContainerRef.injector);
                        var component = moduleRef.instance.routeComponent;
                        _this.renderComponent(component);
                        return true;
                    });
                }
                else {
                    _this.renderComponent(componentOrModule);
                }
                return true;
            }));
        }
        else {
            this.showTemplate();
            return of(true);
        }
    };
    RouteComponent.prototype.renderComponent = function (component) {
        var componentFactory = this.resolver.resolveComponentFactory(component);
        this.showTemplate();
        this.viewContainerRef.createComponent(componentFactory, this.viewContainerRef.length, this.viewContainerRef.injector);
    };
    RouteComponent.prototype.clearComponent = function () {
        this.viewContainerRef.clear();
        this.hideTemplate();
    };
    RouteComponent.prototype.showTemplate = function () {
        var _this = this;
        setTimeout(function () {
            _this.updateState({ shouldRender: true });
        });
    };
    RouteComponent.prototype.hideTemplate = function () {
        this.updateState({ shouldRender: false });
    };
    RouteComponent.prototype.clearView = function () {
        if (this.load) {
            this.clearComponent();
        }
        else {
            this.hideTemplate();
        }
    };
    RouteComponent.prototype.sanitizePath = function (path) {
        var trimmed = path.trim();
        return trimmed.startsWith('/') ? trimmed : "/" + trimmed;
    };
    RouteComponent.prototype.updateState = function (newState) {
        this.state$.next(__assign(__assign({}, this.state$.value), newState));
    };
    var RouteComponent_1;
    RouteComponent.ctorParameters = function () { return [
        { type: Router },
        { type: RouterComponent },
        { type: ComponentFactoryResolver },
        { type: ViewContainerRef },
        { type: Compiler }
    ]; };
    __decorate([
        ContentChild(TemplateRef),
        __metadata("design:type", TemplateRef)
    ], RouteComponent.prototype, "template", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], RouteComponent.prototype, "path", null);
    __decorate([
        Input(),
        __metadata("design:type", Type)
    ], RouteComponent.prototype, "component", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], RouteComponent.prototype, "load", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], RouteComponent.prototype, "reuse", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], RouteComponent.prototype, "redirectTo", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], RouteComponent.prototype, "exact", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], RouteComponent.prototype, "routeOptions", void 0);
    RouteComponent = RouteComponent_1 = __decorate([
        Component({
            // tslint:disable-next-line:component-selector
            selector: 'route',
            template: "\n    <ng-container\n      *ngIf=\"(shouldRender$ | async) && template\"\n      [ngTemplateOutlet]=\"template\"\n    >\n    </ng-container>\n  ",
            changeDetection: ChangeDetectionStrategy.OnPush,
            providers: [
                {
                    provide: RouteParams,
                    useFactory: getRouteParams,
                    deps: [[new Self(), RouteComponent_1]],
                },
                {
                    provide: RoutePath,
                    useFactory: getRoutePath,
                    deps: [[new Self(), RouteComponent_1]],
                },
            ]
        }),
        __metadata("design:paramtypes", [Router,
            RouterComponent,
            ComponentFactoryResolver,
            ViewContainerRef,
            Compiler])
    ], RouteComponent);
    return RouteComponent;
}());

var components = [
    RouterComponent,
    RouteComponent,
    LinkActive,
    LinkTo,
    RouteComponentTemplate,
];
function getQueryParams(router) {
    return router.queryParams$;
}
var RoutingModule = /** @class */ (function () {
    function RoutingModule() {
    }
    RoutingModule_1 = RoutingModule;
    RoutingModule.forRoot = function () {
        return {
            ngModule: RoutingModule_1,
            providers: [
                UrlParser,
                { provide: LocationStrategy, useClass: PathLocationStrategy },
                { provide: QueryParams, deps: [Router], useFactory: getQueryParams },
            ],
        };
    };
    var RoutingModule_1;
    RoutingModule = RoutingModule_1 = __decorate([
        NgModule({
            imports: [CommonModule],
            declarations: [components],
            exports: [components],
        })
    ], RoutingModule);
    return RoutingModule;
}());

/*
 * Public API Surface of router
 */

/**
 * Generated bundle index. Do not edit.
 */

export { LINK_ACTIVE_OPTIONS, LinkActive, LinkTo, QueryParams, RouteComponent, RouteComponentTemplate, RouteParams, RoutePath, Router, RouterComponent, RoutingModule, UrlParser, compareParams, components, getQueryParams, getRouteParams, getRoutePath };
//# sourceMappingURL=angular-routing.js.map
